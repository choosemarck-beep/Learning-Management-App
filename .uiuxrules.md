# UI/UX Skillset Rules - Living Document

> **Purpose**: This is a continuously evolving document that captures UI/UX design principles, learnings, and best practices. It is automatically updated whenever important design insights are discovered during development work.

## How This Document Works

- **Auto-Update**: This file is automatically updated when solving UI/UX problems, discovering better patterns, or learning from user feedback
- **Persistence**: Located in project root (`.uiuxrules.md`) to ensure it's always loaded with context
- **Evolution Log**: All updates are timestamped and documented in the "Evolution Log" section
- **Universal Principles**: Contains universal UI/UX truths that apply across all projects

---

## Foundational Principles

### Accessibility (WCAG AA Compliance)

1. **Color Contrast**
   - Minimum 4.5:1 contrast ratio for normal text (AA standard)
   - Minimum 3:1 contrast ratio for large text (18pt+ or 14pt+ bold)
   - Never rely solely on color to convey information
   - Test with color blindness simulators

2. **Keyboard Navigation**
   - All interactive elements must be keyboard accessible
   - Logical tab order (top to bottom, left to right)
   - Visible focus indicators (2px outline minimum)
   - Skip links for main content navigation
   - Escape key closes modals/dropdowns

3. **Screen Reader Support**
   - Semantic HTML (use proper heading hierarchy, landmarks)
   - ARIA labels for icon-only buttons
   - Alt text for all images (descriptive, not "image of...")
   - Form labels properly associated with inputs
   - Live regions for dynamic content updates

4. **Touch Targets**
   - Minimum 44x44px for all interactive elements (iOS/Android standard)
   - Adequate spacing between touch targets (8px minimum)
   - Larger targets for critical actions (48x48px recommended)
   - **Optimization Note**: Can reduce to 48px height for list items/buttons if padding and spacing are optimized (maintains usability while saving space)
   - **Compact Mobile Design**: When users request more screen space, systematically reduce: padding (md→sm), gaps (md→sm), font sizes (base→sm, sm→xs), border widths (3px→2px), border radius (lg→md)
   - **Balance**: Maintain touch targets but optimize other dimensions (padding, gaps, font sizes) to maximize content visibility

### Cognitive Load Theory

1. **Information Architecture**
   - Limit choices to 5-7 items per decision point (Miller's Law)
   - Group related information together (Gestalt: Proximity)
   - Use progressive disclosure - show only what's needed when needed
   - Clear visual hierarchy guides attention

2. **Chunking**
   - Break complex tasks into 3-5 manageable steps
   - Multi-step forms with progress indicators
   - One primary action per screen when possible
   - Group related fields together

3. **Mental Models**
   - Match user expectations (e.g., "Save" saves, "Cancel" cancels)
   - Use familiar patterns (hamburger menu, search icon, etc.)
   - Consistent navigation patterns throughout
   - Predictable interactions reduce cognitive load

### Gestalt Principles

1. **Proximity**
   - Related items grouped together
   - Adequate spacing between unrelated groups
   - Visual grouping through spacing, not just borders

2. **Similarity**
   - Similar items look similar (buttons, links, form fields)
   - Consistent styling for similar functions
   - Visual consistency reduces learning curve

3. **Closure**
   - Users mentally complete incomplete shapes
   - Use this for loading states, progress indicators
   - Skeleton screens leverage closure principle

4. **Continuity**
   - Elements arranged in lines/curves are perceived as related
   - Use for navigation flows, progress indicators
   - Smooth transitions maintain continuity

5. **Figure/Ground**
   - Clear distinction between content and background
   - Sufficient contrast for readability
   - Focus states clearly distinguish interactive elements

### Fitts' Law & Interaction Design

1. **Target Size**
   - Larger targets are easier to hit
   - Critical actions should have larger touch targets
   - Corner/edge targets are effectively infinite (use for close buttons)

2. **Distance**
   - Frequently used actions should be closer to user's starting point
   - Reduce distance between related actions
   - Mobile: Thumb zone optimization (reachable areas)

3. **Movement Time**
   - Minimize distance for common actions
   - Group related actions together
   - Reduce clicks/taps to complete tasks

---

## Mobile-First Design Principles

### Viewport Constraints

1. **Screen Real Estate**
   - Mobile viewports are limited (320px-428px width typical)
   - Every pixel counts - eliminate unnecessary elements
   - Prioritize content over chrome (navigation, headers)
   - Single column layouts for mobile

2. **Thumb Zone Optimization**
   - Primary actions in thumb-reachable zones
   - Bottom navigation for frequent actions
   - Avoid top corners for critical actions
   - Consider left/right-handed users

3. **Scrolling Behavior**
   - Minimize required scrolling for primary content
   - Critical actions visible without scrolling
   - Use sticky headers/footers for navigation
   - Infinite scroll for content feeds (not forms)

4. **Orientation**
   - Design for portrait first (primary mobile orientation)
   - Test landscape mode for critical flows
   - Lock orientation when necessary (forms, games)

### Touch Interaction Patterns

1. **Tap Targets**
   - Minimum 44x44px (iOS/Android standard)
   - Adequate spacing between targets (8px minimum)
   - Visual feedback on tap (color change, scale, ripple)

2. **Gestures**
   - Swipe for navigation (carousels, lists)
   - Pull-to-refresh for content updates
   - Long-press for secondary actions
   - Pinch-to-zoom for images/maps

3. **Form Input**
   - Large input fields (minimum 44px height)
   - Appropriate keyboard types (email, number, tel)
   - Clear labels above inputs (not inside)
   - Inline validation with helpful error messages

---

## Visual Design Principles

### Typography

1. **Facebook Mobile Typography System** (Applied Globally)
   - **Standard**: All typography follows Facebook's mobile app typography standards for optimal readability
   - **Font Size Hierarchy**:
     - Body Text: 16-18px (`--font-size-base` 16px or `--font-size-lg` 18px)
     - H1: 24-32px (`--font-size-2xl` 24px or `--font-size-3xl` 32px)
     - H2: 20-24px (`--font-size-xl` 20px or `--font-size-2xl` 24px)
     - H3: 18-20px (`--font-size-lg` 18px or `--font-size-xl` 20px)
     - Buttons: 14-18px (`--font-size-sm` 14px or `--font-size-base` 16px)
     - Captions: 12-14px (`--font-size-xs` 12px or `--font-size-sm` 14px)
   - **Line Height Standards** (Facebook-Optimized):
     - Body Text: 1.6x font size (e.g., 16px font = 25.6px line-height)
     - Headings: 1.2-1.4x font size (h1: 1.2x, h2: 1.3x, h3: 1.4x)
     - Buttons: 1.4x font size for optimal touch target readability
     - Labels/Captions: 1.4-1.5x font size for small text readability
   - **Rule**: All future components MUST follow Facebook mobile typography system
   - **Rationale**: Facebook's typography system is research-backed and optimized for mobile readability, ensuring consistent user experience across the application

2. **Hierarchy**
   - Clear size differentiation (1.2-1.5x ratio between levels)
   - Maximum 2-3 font sizes for consistency
   - Weight variation (regular, semibold, bold)
   - Line height: Follow Facebook standards (1.6x for body, 1.2-1.4x for headings, 1.4x for buttons)

3. **Readability**
   - Generous line height prevents text feeling cramped (Facebook-optimized: 1.6x for body)
   - Adequate letter spacing for small text
   - Never cut off text at bottom (proper padding)
   - Text wrapping for long content (no horizontal scroll)

4. **Consistency**
   - Use CSS variables for font sizes/weights
   - Never hardcode pixel values
   - Consistent font family throughout
   - Professional letter/word spacing (no excessive spacing)
   - Follow Facebook mobile typography system globally

### Spacing & Layout

1. **8px Grid System**
   - All spacing multiples of 8px (8, 16, 24, 32, 40, 48)
   - Consistent spacing variables
   - Visual rhythm through consistent spacing

2. **Whitespace**
   - Generous whitespace improves readability
   - Group related elements with less space
   - Separate unrelated sections with more space
   - Don't fear empty space - it's not wasted

3. **Alignment**
   - Consistent alignment creates visual order
   - Align text to baseline grid
   - Align form fields and labels
   - Visual alignment even when not pixel-perfect

### Color & Contrast

1. **Color Psychology**
   - Use color intentionally (not just decoration)
   - Consistent color meanings (green=success, red=error)
   - Cultural considerations for color meanings
   - Accessibility over aesthetics

2. **Contrast**
   - Test all text/background combinations
   - High contrast for body text
   - Medium contrast for secondary text
   - Low contrast for disabled states

3. **Color Blindness**
   - Don't rely solely on color (use icons, patterns, text)
   - Test with color blindness simulators
   - Red/green most common deficiency
   - Blue/yellow also affects some users

---

## Interaction Design Patterns

### Feedback & Response

1. **Immediate Feedback**
   - Every action should have visual feedback
   - Button press states (hover, active, disabled)
   - Loading states for async operations
   - Success/error states clearly communicated

2. **Toast Notifications**
   - Use toasts for non-critical messages (prevents layout shift)
   - Success, error, warning, info variants
   - Auto-dismiss after 3-5 seconds
   - Dismissible with close button
   - Stack multiple toasts vertically

3. **Error Handling**
   - Clear, actionable error messages
   - Inline validation for form fields
   - Prevent errors when possible (validation, constraints)
   - Help users recover from errors easily

### Micro-Interactions

1. **Animation Principles**
   - Purposeful animations (not decorative)
   - Smooth transitions (200-300ms typical)
   - Easing functions (ease-in-out for most)
   - Respect prefers-reduced-motion

2. **Loading States**
   - Skeleton screens for content loading
   - Progress indicators for known duration
   - Spinners for unknown duration
   - Optimistic UI updates when possible

3. **Celebration & Delight**
   - Celebrate achievements (completions, milestones)
   - Playful animations for gamification
   - Positive reinforcement through visual feedback
   - Balance delight with performance

4. **Icon Sizing & Scaling**
   - Icons should scale proportionally with component size
   - **Small Components** (48px height): Use 16-18px icons
   - **Medium Components** (56px height): Use 20-24px icons
   - **Large Components** (64px+ height): Use 24-28px icons
   - **Rationale Headers**: Use smaller icons (16px) to maintain visual hierarchy
   - **Option Buttons**: Icons should be 18px for compact 48px buttons
   - **Consistency**: Maintain consistent icon-to-component size ratios across similar UI elements

### Progressive Disclosure

1. **Information Layering**
   - Show most important information first
   - Hide advanced/optional features initially
   - Expandable sections for details
   - Accordions, tabs, modals for secondary content

2. **Form Design**
   - Multi-step forms for complex data entry
   - Progress indicators show completion
   - One concept per step
   - Save progress when possible

3. **Interactive Assessments (Quizzes/Tests)**
   - **Confirmation Step**: Add confirmation before revealing answers to prevent accidental clicks and increase intentionality
   - **Progressive Reveal**: Confirmation → Answer Reveal → Explanation → Next Button (one step at a time)
   - **Intentional Selection**: Users should confirm their choice before seeing results (reduces anxiety, increases engagement)
   - **Visual Feedback Sequence**: Selection highlight → Confirmation prompt → Answer reveal with animation → Explanation → Action button
   - **Example Flow**: User clicks option → "Are you sure?" confirmation appears → User confirms → Answer revealed with color/animation → Explanation shown → Continue button appears

---

## User Psychology & Behavioral Science

### Positive Framing

1. **Language**
   - Frame challenges as opportunities
   - Use positive language ("You're making progress!" vs "You haven't completed this")
   - Celebrate small wins
   - Avoid negative framing when possible

2. **Loss Aversion**
   - Emphasize what users gain (not what they lose)
   - Use carefully - can create anxiety
   - Progress indicators show what's gained
   - Completion states celebrate achievement

3. **Social Proof**
   - Show what others are doing (when appropriate)
   - Testimonials, reviews, user counts
   - Leaderboards for gamification
   - Community activity indicators

### Cognitive Biases (Leverage Wisely)

1. **Anchoring**
   - First impression sets expectations
   - Use for pricing, feature comparisons
   - Onboarding sets tone for entire experience

2. **Confirmation Bias**
   - Users seek information confirming beliefs
   - Provide clear, accurate information
   - Don't manipulate - inform honestly

3. **Choice Paralysis**
   - Too many options = no decision
   - Limit choices to 3-5 options
   - Provide recommendations/defaults
   - Guide users to best choice

---

## Problem-Solution Patterns

### Common Problems & Solutions

1. **Layout Shifts**
   - **Problem**: Content jumping when loading
   - **Solution**: Reserve space with skeleton screens, fixed heights, aspect ratios
   - **Prevention**: Toast notifications instead of inline messages

2. **Text Clipping**
   - **Problem**: Text cut off at bottom of container
   - **Solution**: Adequate line-height, padding, container height
   - **Prevention**: Test with long content, use proper CSS

3. **Icon Distortion**
   - **Problem**: Icons stretched or squashed
   - **Solution**: Maintain aspect ratio, use consistent sizes
   - **Prevention**: Use icon libraries, proper sizing constraints

4. **Form Overwhelm**
   - **Problem**: Too many fields at once
   - **Solution**: Multi-step forms, progressive disclosure
   - **Prevention**: Chunk related fields, show progress

5. **Unclear Actions**
   - **Problem**: Users don't know what to do next
   - **Solution**: Clear CTAs, visual hierarchy, guidance
   - **Prevention**: User testing, clear information architecture

6. **Mobile Viewport Overflow**
   - **Problem**: Content doesn't fit on mobile screen
   - **Solution**: Compact spacing, prioritize content, reduce padding
   - **Prevention**: Test at 320px, 375px, 428px widths

7. **Inconsistent Spacing**
   - **Problem**: Visual chaos from random spacing
   - **Solution**: Use spacing variables, 8px grid system
   - **Prevention**: Design system with defined spacing scale

---

## Design Quality Standards

### Visual Polish

1. **Consistency**
   - Consistent spacing, typography, colors throughout
   - Reusable components maintain consistency
   - Design system enforces consistency

2. **Alignment**
   - Elements aligned to grid
   - Text aligned consistently
   - Visual alignment creates order

3. **Balance**
   - Visual weight distributed evenly
   - White space balanced
   - No single area too heavy/light

4. **Contrast**
   - Sufficient contrast for readability
   - Visual hierarchy through contrast
   - Focus states clearly visible

### Professional Standards

1. **No Visual Glitches**
   - No text clipping or overflow
   - No icon distortion
   - No layout breaks
   - No color contrast issues

2. **Proper Containers**
   - Adequate padding prevents clipping
   - Proper height for content
   - Responsive to content length

3. **Responsive Text**
   - Text wraps properly
   - No horizontal scrolling
   - Proper line breaks
   - Readable at all sizes

---

## Evolution Log

> This section documents learnings and updates as they occur. Each entry includes date, context, learning, and application.

### 2024-12-XX - Initial Creation
**Context**: Creating foundational UI/UX skillset rules document
**Learning**: Comprehensive UI/UX principles need to be captured in a persistent, evolving document
**Application**: This document will be automatically updated whenever important design insights are discovered during development work

---

### 2024-12-XX - Password Input Design & Security Best Practices
**Context**: Implementing password reset flow with show/hide password toggle and secure reset journey
**Learning**: 
1. **Password Input Toggle Design**: Show/hide password icons should be minimalist, white monotone, and positioned inside the input field on the right side. Use Eye/EyeOff icons from Lucide React at 16px size for compact inputs. The toggle button should be transparent with hover states, maintaining visual hierarchy without distracting from the input.
2. **Security-First Password Reset Flow**: Implement a multi-step, secure password reset journey: (1) Forgot password page with email input, (2) Token generation with crypto.randomBytes for security, (3) Email delivery with reset link, (4) Token validation before showing reset form, (5) Password reset with strong validation. Never reveal if email exists (prevent enumeration attacks).
3. **Email Enumeration Prevention**: Always return the same success message whether the email exists or not. This prevents attackers from discovering valid email addresses. Log errors server-side but don't expose them to clients.
4. **Token Security**: Use cryptographically secure random tokens (32 bytes), set expiration (1 hour), and clear tokens after use. Validate tokens server-side before allowing password reset.
5. **Password Validation**: Enforce strong passwords (8+ chars, uppercase, lowercase, number, special char) on both client and server. Use Zod schemas for validation consistency.
6. **User Experience in Security Flows**: Show clear success states ("Check your email"), provide helpful error messages without revealing security details, and include "Back to Sign In" links for easy navigation. Use loading states during token validation.

**Application**: 
- Create PasswordInput component with internal toggle button (Eye/EyeOff icons, 16px, white monotone)
- Position toggle button absolutely inside input field on the right
- Implement forgot password → email → token validation → reset password flow
- Always return generic success messages (prevent email enumeration)
- Use crypto.randomBytes for token generation
- Set token expiration (1 hour) and clear after use
- Validate passwords with strong requirements on client and server
- Show clear success/error states with helpful navigation

**Example**: PasswordInput with Eye icon toggle (16px, white, inside right), forgot password flow with email enumeration prevention, secure token-based reset.

---

### 2024-12-XX - Quiz/Assessment UI Patterns & Mobile Spacing Optimization
**Context**: Redesigning quiz interface with Duolingo-style UX and optimizing for mobile screen space
**Learning**: 
1. **Confirmation Before Reveal**: Adding a confirmation step before revealing quiz answers increases intentionality, reduces accidental clicks, and improves user engagement. Users should confirm their selection before seeing results.
2. **Progressive Disclosure in Assessments**: The optimal flow is: Selection → Confirmation → Answer Reveal → Explanation → Next Action. Each step should appear sequentially, not simultaneously.
3. **Mobile Spacing Optimization**: When users request more screen space, systematically reduce: padding (md→sm), gaps between elements (md→sm), font sizes (base→sm, sm→xs), border widths (3px→2px), and border radius (lg→md). This maintains usability while maximizing content visibility.
4. **Icon Scaling**: Icons must scale proportionally with component sizes. For compact 48px buttons, use 18px icons. For rationale headers, use 16px icons. Maintain consistent icon-to-component size ratios.
5. **Touch Target Optimization**: Can reduce button heights to 48px (from 64px) if padding and spacing are optimized, maintaining usability while saving vertical space.

**Application**: 
- Implement confirmation step in all interactive assessments before revealing answers
- Use progressive disclosure pattern: confirmation → reveal → explanation → action
- When optimizing for space, reduce padding, gaps, font sizes, and borders systematically
- Scale icons proportionally: 16-18px for small components, 20-24px for medium, 24-28px for large
- Balance compactness with readability and touch target requirements

**Example**: Quiz interface with 48px option buttons (18px icons), compact confirmation dialog (sm padding, sm gaps), xs font for options, and sequential reveal pattern.

---

### 2024-12-XX - Graceful Image Loading & Error Handling
**Context**: Handling 404 errors for uploaded images (carousel, avatars, splash screen) in serverless environments
**Learning**: 
1. **Graceful Degradation for Images**: When images fail to load (404, network errors, missing files), always provide fallback placeholders instead of showing broken image icons. This maintains visual consistency and prevents layout shifts.
2. **Error Handling in Image Components**: Use `onError` handlers on all `<img>` tags to automatically replace failed images with placeholders. This provides seamless user experience without requiring user intervention.
3. **Placeholder Strategy**: Create consistent placeholder images for different content types (avatar placeholder, carousel placeholder, thumbnail placeholder). Use neutral, branded placeholders that match the design system.
4. **Loading States**: Show skeleton screens or loading spinners while images load, especially for user-uploaded content that may take time to fetch from cloud storage.
5. **Serverless Storage Considerations**: In serverless environments (Vercel, Netlify), never use local filesystem for user uploads. Always use cloud storage (Vercel Blob, S3, Cloudinary) to ensure persistence across deployments.
6. **User Feedback**: When image uploads fail, provide clear, actionable error messages. Don't silently fail - inform users and provide retry options.

**Application**: 
- Add `onError` handlers to all image components: `<img onError={(e) => e.currentTarget.src = '/placeholder.png'} />`
- Create placeholder images for avatars, carousels, thumbnails, and splash screens
- Use Next.js `Image` component with `onError` prop when possible
- Show loading states during image uploads and fetches
- Validate image URLs before rendering (check if URL exists or use placeholder)
- Implement cloud storage for all user-uploaded content in production
- Provide user-friendly error messages when uploads fail

**Example**: Carousel image component with fallback placeholder, avatar with default user icon on error, loading skeleton for image galleries.

---

### 2024-12-30 - Overflow Hidden Clipping & Dynamic Content Visibility
**Context**: Fixing quiz confirmation popup that was hidden when user selected an answer, preventing progression
**Learning**: 
1. **Parent Container Overflow Clipping**: Parent containers with `overflow: hidden` can clip child elements that appear dynamically (modals, popups, confirmation dialogs). This is especially problematic when child elements need to be visible above the parent's boundaries.
2. **Component-Specific Overflow Overrides**: When a reusable component (like CardBody) has `overflow: hidden` by default, child components that need visible overflow must override it with component-specific CSS classes. Use `!important` sparingly but appropriately for critical overrides.
3. **Z-Index Stacking Context**: Elements that need to appear above others require explicit z-index values. Use `position: relative` or `position: absolute` with z-index to ensure proper stacking order.
4. **Scroll-Into-View for Dynamic Content**: When content appears dynamically (confirmation popups, error messages, success states), use `scrollIntoView()` with smooth behavior to ensure users can see the new content, especially on mobile viewports where content might be pushed out of view.
5. **Transform for Hardware Acceleration**: Using `transform: translateZ(0)` creates a new stacking context and enables hardware acceleration, which can help with z-index issues and improve rendering performance.
6. **Testing Dynamic Content Visibility**: Always test confirmation dialogs, modals, and dynamically appearing content on mobile viewports (320px-428px) to ensure they're not clipped or hidden.

**Application**: 
- Override parent container overflow for components that need visible overflow: `.componentBody { overflow: visible !important; overflow-y: auto !important; }`
- Add explicit z-index to elements that need to appear above others: `z-index: 10; position: relative;`
- Use scroll-into-view when content appears dynamically: `element.scrollIntoView({ behavior: 'smooth', block: 'nearest' })`
- Add `transform: translateZ(0)` for hardware acceleration when dealing with z-index issues
- Test all confirmation dialogs and modals on mobile viewports
- Check parent container overflow settings when child elements are clipped

**Example**: Quiz confirmation popup with overflow override on CardBody, z-index positioning, and scroll-into-view behavior when popup appears.

---

### 2025-01-01 - Facebook Mobile Typography System Implementation
**Context**: Applying Facebook's mobile app typography system globally across the entire webapp for optimal readability and user experience.

**Learning**: 
1. **Facebook Typography Research**: Facebook's mobile app uses research-backed typography standards: Body 16-18px, H1 24-32px, H2 20-24px, H3 18-20px, Buttons 14-18px, Captions 12-14px
2. **Line Height Optimization**: Facebook uses specific line-height ratios: 1.6x for body text, 1.2-1.4x for headings, 1.4x for buttons, 1.4-1.5x for labels/captions
3. **Existing Alignment**: Our font size variables already align perfectly with Facebook's hierarchy - no changes needed to font sizes
4. **Global Application**: Typography standards should be applied globally in `globals.css` to ensure consistency across all components
5. **Documentation as Rule**: Typography standards must be documented as permanent rules in `.cursorrules`, `.uiuxrules.md`, and `docs/CONTEXTBIBLE.md` to ensure all future development follows the system

**Application**: 
- Added global line-height rules in `app/globals.css` following Facebook standards (1.6x body, 1.2-1.4x headings, 1.4x buttons)
- Documented Facebook Typography System in `.cursorrules` with font size mapping and line-height standards
- Added to `.uiuxrules.md` Typography section and Evolution Log
- Updated `docs/CONTEXTBIBLE.md` Typography section with Facebook standards
- Established rule: "All future components MUST follow Facebook mobile typography system"

**Example**: 
- Body text: `font-size: var(--font-size-base)` (16px) with `line-height: 1.6` (25.6px)
- Headings: `font-size: var(--font-size-2xl)` (24px) with `line-height: 1.3` (31.2px)
- Buttons: `font-size: var(--font-size-sm)` (14px) with `line-height: 1.4` (19.6px)

---

## Update Guidelines

### When to Update This Document

1. **Solving New Problems**: When encountering and solving a UI/UX problem not covered here
2. **Discovering Better Patterns**: When finding a more effective design pattern
3. **Edge Cases**: When handling edge cases that reveal new principles
4. **User Feedback**: When user feedback reveals design issues
5. **Accessibility Improvements**: When discovering accessibility improvements
6. **Performance Insights**: When performance issues reveal design trade-offs
7. **Platform Learnings**: When learning platform-specific best practices

### How to Update

1. **Add to Relevant Section**: Update the appropriate section with new learning
2. **Add to Evolution Log**: Document the update with date, context, learning, and application
3. **Be Specific**: Include concrete examples and actionable guidance
4. **Maintain Structure**: Keep document organized and easy to navigate

### Update Format

```markdown
### [YYYY-MM-DD] - [Context/Feature]
**Learning**: [What was learned - specific insight]
**Application**: [How to apply this learning]
**Example**: [Real example from project if applicable]
```

---

## References & Resources

### Standards
- WCAG 2.1 AA Guidelines
- iOS Human Interface Guidelines
- Material Design Guidelines
- Web Content Accessibility Guidelines

### Principles
- Gestalt Principles
- Fitts' Law
- Miller's Law (7±2)
- Cognitive Load Theory
- Progressive Disclosure

### Tools
- Color contrast checkers
- Screen reader testing
- Keyboard navigation testing
- Mobile viewport testing
- Accessibility audit tools

---

**Last Updated**: 2025-01-01
**Version**: 1.4.0
**Status**: Active - Continuously Evolving

